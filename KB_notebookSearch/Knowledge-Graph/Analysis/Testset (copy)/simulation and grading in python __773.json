{"name": "simulation and grading in python ", "full_name": " h1 Simulation and Grading in Python ", "stargazers_count": 0, "forks_count": 0, "description": "The index of the street The Intersection object at the start of the street The Intersection object at the end of the street A str The length of the street in seconds A dict mapping car ids int to remaining seconds A deque of car ids int A dict mapping car ids int to their arrival times A dict mapping car ids int to their departure times You can compute the seconds that a car was waiting at the end of the street by subtracting the arrival time from the departure time. A bool indicating whether the green_street ever needs to be updated during the simulation i. A list mapping t mod schedule_duration. com huikang sample submission with green light duration of one which yields a score of 4020533. Update the green street Drive across the intersection Drive across roads Store the ids of streets that don t have driving cars after this. For intersections we need to update some attributes during the simulation which namedtuple does not allow. Iterate through the schedules and initialize the intersections. Reached the end of the street FINISH The car is still driving on the street We are done with the simulation. the remaining driving seconds. whether the schedule has more than one street. We only use street indices and intersection indices here to allow fast deep copies of a schedule for testing out and reverting modifications. The sum of green times of all incoming streets in the schedule. The index of the intersection A deque of incoming Street objects A deque of outgoing Street objects The Street object that currently has a green light. For example we can increase the green times of streets where a lot of cars had to wait. At the very end we try out the grader on the output of Sample Submission with green light duration of one https www. Update the time to live of this car i. Simulation and Grading in PythonRunning the simulation and computing the final score allows us to gather analytics data find bottlenecks and update the schedules correspondingly. We can also do some hill climing by randomly adjusting schedules and using the grading function to see whether we improved. The index of the intersection A list of street ids A dict mapping street ids to green times seconds Parse the first line Create empty intersections Parse the streets Parse the paths Reinitialize mutable data structures We will consume the deques in the paths list. intersection_ids_with_waiting_cars is restricted to intersections with schedules Main simulation loop Drive across intersections Store the ids of intersections that don t have waiting cars after this. We use namedtuple for representing streets schedules and intersections. Will be wrapped in a MutableValue with a val attribute to allow mutating the value without mutating the namedtuple. Therefore we use this class to allow modifying a wrapped value without changing the attribute in the namedtuple. For this it would be best to use the recordclass package instead but it is not available in the Kaggle Python docker image. val to the street object that is green at time t. An int representing the total number of waiting cars across all incoming streets of this intersection. Save a copy of them for later to reset the paths after the simulation. In this notebook you find ready to use data structures and functions that you can copy into your own code base to grade and improve your solutions. ", "id": "batzner/simulation-and-grading-in-python", "size": "773", "language": "python", "html_url": "https://www.kaggle.com/code/batzner/simulation-and-grading-in-python", "git_url": "https://www.kaggle.com/code/batzner/simulation-and-grading-in-python", "script": "__init__ collections MutableValue namedtuple deque read_answer reinit grade read_input ", "entities": "(('green_street', 'simulation ever i.'), 'bool') (('We', 'paths list'), 'index') (('schedule', 'more than one street'), 'have') (('that', 'time'), 'val') (('instead it', 'Kaggle Python docker image'), 'be') (('where lot', 'cars'), 'increase') (('don t', 'this'), 'restrict') (('which', '4020533'), 'com') (('don t', 'this'), 'update') (('that', 'currently green light'), 'object') (('car', 'departure time'), 'object') (('analytics data', 'schedules'), 'allow') (('We', 'streets schedules'), 'use') (('We', 'modifications'), 'use') (('you', 'solutions'), 'find') (('We', 'simulation'), 'reach') (('we', 'https one www'), 'try') (('namedtuple', 'which'), 'need') (('we', 'grading function'), 'do') (('Therefore we', 'namedtuple'), 'use') ", "extra": "['test']", "label": "Perfect_files", "potential_description_queries": ["attribute", "best", "bool", "car", "code", "compute", "copy", "data", "deque", "dict", "duration", "empty", "end", "final", "find", "function", "grade", "grading", "green", "improve", "increase", "index", "initialize", "int", "intersection", "length", "light", "line", "list", "loop", "lot", "mapping", "mod", "namedtuple", "need", "not", "notebook", "number", "object", "out", "output", "package", "reset", "sample", "schedule", "score", "simulation", "start", "str", "submission", "sum", "testing", "through", "time", "total", "try", "update", "val", "value"], "potential_description_queries_len": 59, "potential_script_queries": ["grade"], "potential_script_queries_len": 1, "potential_entities_queries": [], "potential_entities_queries_len": 0, "potential_extra_queries": ["test"], "potential_extra_queries_len": 1, "all_components_potential_queries_len": 60}