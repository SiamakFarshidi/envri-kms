{"name": "morphological postprocessing on unet lb 0 429 ", "full_name": " h2 In this notebook we explain our morphological postprocessing step that improved our score from 0 421 to 0 429 on LB h1 Plan h1 What we need h1 Clean Masks h2 Problem 1 dirty masks h2 Problem 2 dirty at border h2 Approach V1 h2 Approach V2 h1 Problem 3 not everything gets filled h1 Problem 4 some cells get connected h1 Ideas h1 Good Markers h1 Approach v1 h2 Problem 1 building markers on initial mask when we have better mask h2 Problem 2 some markers are to large and connected h2 Problem 3 still some barely connected markers are left h2 Problem 4 we are dropping markers on many images with small cells h2 Ideas h1 Good distance h2 Idea h2 Watershed h2 Problem 1 some cells are dumped h2 Problem 2 some artifacts from mask cleaning remain h2 Problem 3 some cells are oversemgmented and small cell chunks remain h1 LB Test set predictions ", "stargazers_count": 0, "forks_count": 0, "description": "In order to get there we can use binary_erosion Let s first do what we knowFor instance the two markers at the top left are still connected and will be treated as a single marker by the watershed. com neptune ml data science bowl 2018To stay up to date with new features and fully open sourced solution with predictions read our data science bowl journal thread https www. We will need to to choose the structural element for our postprocessingLet s work on image 5Now let s proceed to cleaning. htm but there is a ton of stuff online so google it if you feel like it. But that I will leave for you to create If you liked the solution and would like to see how it works as a part of the end to end pipeline please go to https github. com neptune ml data science bowl 2018Lets look at our inputs maps contoursand outputs ground truthto get some intuition into what is possibleBoth masks and contours seem reasonably good and sometimes like in image 5 it is very beneficial to use both Plan We will use marker based watershed to detach nuclei and combine that with some morphological cleaningIf you don t know what it is check this link http cmm. Ok putting it all together gives us Problem 3 some cells are oversemgmented and small cell chunks remainNow some small pieces of cells may remain at this point or the cells could get oversegmented. By the way do you know why the cells that are visible on the mask are sometimes dropped in the watershed I will not answer it know but simply solve it by adding the dropped cells to the output. Of course there is still a lot of room for improvement. If it is the first time you hear about them it s a good moment to do some reading. First we binarize both the mask and contours using global otsu thresholding method Then we go ahead and combine binarized masks and contours and fill the holes that remainedNow that we filled the holes in the cells we can detach them again because we have the contour informationThere is a problem with this approach. If we could clean up those small artifacts we would be almost golden. Here is an interesting link https homepages. html What we need Clean binary masks Good nicely detached markers Good distance Clean Masks Problem 1 dirty masks Problem 2 dirty at borderWe can immediately see that some of our cells are are not very smooth and there are holes in them. First we have slightly smaller cells like the blue one on the right edge and we created some new cells like the one at the top edge. Also there are artifacts that aren t supposed to be there Ideas work more with dilation do better around borders drop some cells after watershed with drop_artifact functionGo ahead and try to improve it. Problem 4 we are dropping markers on many images with small cells Ideas play with binary closing opening involve contours and or centers in this we will asume that lost markers are in facet small cells that don t need to be divided and we will get back all the cells that were dropped in watershed use local maxima on distance transform Good distanceHere I have no better idea than to use the binary distance from the background. We need to make them better smaller and positioned more in the center of nuceli. Let s put it all together in a functionIt works to a certain extend but it removes things that where not connected and or things around borders Approach V2Let s start by binarizing and filling the holes againNow we will use binary_closing to fill what wasn t closed with fill holes. Let s deal with it one problem at a time starting with the two small cell problem. Let s deal with that via morphological transformations. If nothing was there at the beginning nothing should be there now. And nowe lets erode the markersok thats not bad if we now compare those markers with the labels we get the followingSo the markers and cleaned mask look really good Problem 3 still some barely connected markers are leftUnfortunately for some images the markers are not eroded enough and are left connected look at the orange blob at the bottom right corner in the forth column. We ll deal with the second problem by going over all the resulting cells and calculating the coverage of the cell with the original binaraized image region. We can simply join the result with the original binarized mask. 429 on LBTo see the full end to end pipeline go to https github. In this notebook we explain our morphological postprocessing step that improved our score from 0. Luckily we can use binary_openning with a larger structural element. Let s try the simplest option without any tweaks Problem 1 some cells are dumped Problem 2 some artifacts from mask_cleaning remainUnfortunatelly some cells are dropped some cells are oversegmented and some artifacts from the mask cleaning still remain. We are left with artifacts. However when we drop them and those oversegmentations happen in the middle of the cell we might end up with a hole. We will need two helper functions pad_mask and crop_mask to deal with problems around the edges ok lets go for itYeah we closed everything but it is way more than we wanted. The floor is yours Good MarkersLet s now try end extract good markers for our watershed. For cells that get oversegmented we should implement a function that glues those oversegmented cells together rather than drop them. Approach v1In this approach we will simply cut the masks with the contours and use that as markers. Approach V1Let s build a function that calculates the average size of the nuclei. That is why we will iterate over every connected component and apply binary_fill_hole to it to remove that problem. Problem 1 building markers on initial mask when we have better maskThere is no point in using initial masks when we worked so hard on making them better right Let s use our results from the first step Problem 2 some markers are to large and connectedUnfortunately it is not perfect. Let s do that with the following drop_artifacts functionNot bad at all Let s put it all together in one functionIt is still not perfect for instance the following problems still arise Problem 3 not everything gets filledLook at the blue cell on the yellow and blue cells on the left Problem 4 some cells get connectedLook at this large blob at the top. When it comes to artifacts left we will recycle the idea of dropping cells that weren t visible on the initial image. com c data science bowl 2018 discussion 47590 Cheers and good luck LB Test set predictions threshold combine contours and masks and fill the cells close what wasn t closed before join the connected cells with what we had at the beginning threshold combine contours and masks and fill the cells close what wasn t closed before open to cut the real cells from the artifacts join the connected cells with what we had at the beginning drop all the cells that weren t present at least in 25 of area in the initial mask threshold threshold threshold. Remember that some cells that are touching are detached by watershed. If we have to connected cells and we have one connected marker for those cells watershed will not detach it. Let s use binary_openning to drop them. Voila This solution works reasonably well. Only difference is that now we need to iterate over connected components and apply drop artifacts to each component. Let s now cut it with our contours and see what we getWe got a lot of artifacts but we are getting places. There are two problems with this result. The good thing is we can deal with some of those problems by using ideas we have already tried. Let s try thatBoom It looks really nice. Some tweaking should improve it but beware that for other images it might decrease the score. Simple but really effective. We will deal with that by dropping to small to be a cell blobs. Feel free to improve on that Idea investigate imposing some gradients on original image or good clean mask WatershedNow that we have good masks markersa and distance we can proceed to the watershed algorithm. ", "id": "jakubczakon/morphological-postprocessing-on-unet-lb-0-429", "size": "7800", "language": "python", "html_url": "https://www.kaggle.com/code/jakubczakon/morphological-postprocessing-on-unet-lb-0-429", "git_url": "https://www.kaggle.com/code/jakubczakon/morphological-postprocessing-on-unet-lb-0-429", "script": "fill_holes_per_blob good_markers_v2 product ipywidgets mean_blob_size drop_artifacts_per_label clean_mask_v2 drop_artifacts skimage.morphology joblib good_markers_v1 drop_small good_markers_v4 itertools good_markers_v3 clean_mask_v3 scipy.ndimage numpy skimage.filters add_dropped_water_blobs scipy.stats skimage.color threshold_otsu clean_mask_v1 sklearn.externals itemfreq matplotlib.pyplot good_distance_v1 label2rgb pandas relabel crop_mask watershed_v1 pad_mask watershed_v3 plot_list watershed_v2 ", "entities": "(('it', 'score'), 'improve') (('s', 'morphological transformations'), 'let') (('We', 'original binarized mask'), 'join') (('why we', 'problem'), 'be') (('way we', 'everything'), 'need') (('instance two markers', 'watershed'), 'use') (('we', 'small artifacts'), 'clean') (('We', 'small'), 'deal') (('I', 'background'), 'drop') (('that', 'nuclei'), 'build') (('markers', 'forth column'), 'erode') (('again we', 'informationThere approach'), 'binarize') (('how it', 'https github'), 'leave') (('Luckily we', 'larger structural element'), 'use') (('link', 'cmm'), 'ml') (('work', 'functionGo ahead it'), 'be') (('now we', 'component'), 'be') (('we', 'watershed algorithm'), 'feel') (('it', 'output'), 'know') (('it', 'first step'), 'be') (('that', 'watershed'), 'remember') (('you', 'it'), 'htm') (('we', 'top edge'), 'have') (('immediately some', 'very them'), 'html') (('that', 'together rather them'), 'implement') (('wasn t', 'fill holes'), 'let') (('it', 'good reading'), 's') (('them', 'nuceli'), 'need') (('com data science bowl 2018To', 'data science bowl journal thread https www'), 'neptune') (('pipeline', 'https github'), 'see') (('that', '0'), 'explain') (('s', 'image'), 'need') (('we', 'hole'), 'end') (('that', 'initial image'), 'leave') (('4 cells', 'top'), 'let') (('cells', 'point'), 'give') (('We', 'image original binaraized region'), 'deal') (('Good MarkersLet', 'watershed'), 'be') (('s', 'cell two small problem'), 'let') (('we', 'it'), 'detach') (('we', 'places'), 'let') (('approach we', 'markers'), 'Approach') (('that', 'mask threshold threshold initial threshold'), 'bowl') (('we', 'ideas'), 'be') (('artifacts', 'mask cleaning'), 'let') (('nothing', 'there beginning'), 'be') ", "extra": "['test']", "label": "Perfect_files", "potential_description_queries": ["answer", "apply", "approach", "area", "average", "binarize", "binary", "blob", "bottom", "build", "cell", "center", "check", "choose", "clean", "cleaning", "close", "closing", "combine", "compare", "contour", "could", "course", "create", "cut", "data", "date", "difference", "dilation", "distance", "drop", "edge", "end", "every", "everything", "extend", "extract", "fill", "floor", "following", "function", "google", "ground", "helper", "http", "idea", "image", "implement", "improve", "instance", "intuition", "join", "least", "leave", "left", "let", "link", "local", "look", "lost", "lot", "mask", "method", "middle", "might", "ml", "moment", "need", "new", "no", "not", "notebook", "nuclei", "open", "opening", "option", "order", "otsu", "part", "pipeline", "point", "present", "problem", "read", "remove", "result", "right", "room", "science", "score", "second", "set", "single", "size", "smooth", "solution", "start", "step", "stuff", "those", "threshold", "thresholding", "time", "transform", "try", "up", "watershed", "work"], "potential_description_queries_len": 108, "potential_script_queries": ["joblib", "label2rgb", "numpy", "product", "relabel"], "potential_script_queries_len": 5, "potential_entities_queries": ["science"], "potential_entities_queries_len": 1, "potential_extra_queries": ["test"], "potential_extra_queries_len": 1, "all_components_potential_queries_len": 114}