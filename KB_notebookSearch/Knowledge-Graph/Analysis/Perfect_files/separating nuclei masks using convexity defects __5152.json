{"name": "separating nuclei masks using convexity defects ", "full_name": " h1 Statement of the problem h2 1 Show some examples h2 2 Describe the separation idea h3 2 1 Convex enough h3 2 2 Correcting con conex masks h2 3 Modify public kernel Pure image processing LB 0 274 ", "stargazers_count": 0, "forks_count": 0, "description": "2 Correcting con conex masksThe idea is based on the example here http https docs. The analysis bellow makes the assumption that nuclei are convex shaped This is not 100 correct. Use the splitting methology to each case Let us see what happened to three cases By visually inspecting we can see some good cases and some over splitted cases. We can move to correction 2. 1 print no convex Let us apply the above filter to the 42 masks of the example above I guess by now we have a pretty good indication of convexity. connectedComponents to split it into disjoint masks3. Breaks the masks by filtering value mask_i mask i. The basic idea is described in the steps below 1. Except this function which does apply the separation and filtering 1. 1 Convex enoughWe use skimage. 0 We need then normalized distance to be greater than 12. This is naively implemented using two nested loops for i in range len points f1 points i p1 tuple contour f1 0 nearest None min_dist np. Identify convexity defects points b. dist p1 0 p2 0 p1 0 p2 0 p1 1 p2 1 p1 1 p2 1 if dist min_dist. Appends the splitted mask into a listFinally all masks are grouped together once more into as single one np. The separating method can be applied to a segmentation output after applying skimage label or methods of sort to separated connected clusters. Essentially we gather all defect points and filter them using this approximate distance. In the code below we filter the defect points according to http 1. Connect point p1 to its nearest one. 1 proceeds on splitting the mask5. More details here http https docs. amax masks axis 0 and we call label to separate them once more. Statement of the problemIn this notebook I briefly describe a naive method that attempts to separate merged overlapping nuclei masks using OpenCV convexity analysis. Process each test image and create initial masks. AcUse the skimage label to separate the masks into connected blobs. The defect points are returned as as list of start point end point farthest point approximate distance to farthest point. Modify public kernel Pure image processing LB 0. Show some examples of overlapping nuclei2. If it is bigger than a predefined threshold then the shape of the mask is non convex. amax of all corresponding masks. However I am working on some extentions Connecting only nearest convexity defect points is obviously a poor way For masks near the margins we may not find symmetric convexity defect point id 0 is for background In this loop we gather all defect points so that they can be filtered later on. There is no free lunch after all. line thresh p1 nearest 0 0 0 2 Let us see the separation in action. After gathering all convexity defect points we begin connecting them by simply connecting the two nearest each time. More specifically we check the ratio of prop. Plot second image 7f34dfccd1bc2e2466ee3d6f74ff05821a0e5404e9cf2c9568da26b59f7afda5 and the np. Draw a line of background 0 color to connect every two nearest defect points 2. Calculate the regionprops properties props regionprops mask_i cache False 4. Takes as input as mask created by cv2. regionprops method to characterize each individual mask. I guess by now you have noticed cases like mask 1 mask 5 mask 12 and mask 13 that deviate from nice convex shapes. That means that background is set to 0 and mask pixels have values from 1 2. Apply the correction to one of the benchmar submissions It actually improved LB 0. Describe the convexity based separation code3. inf for j in range len points. We can use the approximate distance to the farthest point as indication of badness. Show some examplesLet us read some train images and their corresponding masks. 0 beta doc py_tutorials py_imgproc py_contours py_contours_more_functions py_contours_more_functions. Given a segmentation mask2. measure import regionprops props regionprops mask_i cache False prop props 0 if prop. 2 We need the point to be at least 80 far compared to the farthest point. Our aim is to locate convexity defect points and connect them with a straight line background color hence separating them. com ahassaine pure image processing lb 0 274 Most of the following code is borrowed from the Ali Hassa\u00efne s public kernel. green channel happends to produce slightly better results than the grayscale image and other channels morphological opening size tuned on training data Otsu thresholding Invert the image in case the objects of interest are in the dark side second morphological opening on binary image this time connected components id 0 is for background. Describe the separation ideaThe idea is to operate on a blob by blob fashion and detect the points that deviate from the convex hull that is around the blob. For each one disjoint mask If the disjoint mask is not convex enough a. ", "id": "voglinio/separating-nuclei-masks-using-convexity-defects", "size": "5152", "language": "python", "html_url": "https://www.kaggle.com/code/voglinio/separating-nuclei-masks-using-convexity-defects", "git_url": "https://www.kaggle.com/code/voglinio/separating-nuclei-masks-using-convexity-defects", "script": "regionprops IPython.display rle_encoding pyplot numpy Image skimage.measure label matplotlib split_mask_v1 pyplot as plt process skimage.morphology split_and_relabel ", "entities": "(('we', 'http'), 'filter') (('We', 'badness'), 'use') (('con conex masksThe 2 Correcting idea', 'https here docs'), 'base') (('We', '12'), 'need') (('Essentially we', 'approximate distance'), 'gather') (('More specifically we', 'prop'), 'check') (('disjoint mask', 'enough a.'), 'for') (('they', 'defect points'), 'be') (('defect points', 'start point end point farthest point approximate distance'), 'return') (('we', 'convexity'), 'print') (('then shape', 'mask'), 'be') (('that', 'OpenCV convexity analysis'), 'statement') (('props', 'mask_i cache'), 'calculate') (('skimage', 'connected blobs'), 'label') (('mask pixels', '1 2'), 'mean') (('image processing com ahassaine pure 0 274 Most', 'Ali public kernel'), 'lb') (('that', 'blob'), 'describe') (('nuclei', 'This'), 'make') (('separating method', 'connected clusters'), 'apply') (('0 2 us', 'action'), 'let') (('visually we', 'splitted cases'), 'let') (('0 we', 'them'), 'axis') (('i', 'background'), 'be') (('It', 'benchmar submissions'), 'apply') (('which', '1'), 'except') (('masks', 'together once more single one np'), 'group') (('basic idea', '1'), 'describe') (('f1 points i', 'range len points'), 'implement') (('us', 'train images'), 'show') (('12 13 that', 'convex nice shapes'), 'guess') (('mask_i cache False prop', '0'), 'regionprop') (('aim', 'hence them'), 'be') (('we', 'simply two nearest'), 'begin') (('We', 'at least 80 far farthest point'), '2') ", "extra": "['test']"}