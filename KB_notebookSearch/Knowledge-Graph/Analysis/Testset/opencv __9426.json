{"name": "opencv ", "full_name": " h2 OpenCV h4 This gives us two advantages h1 Import Library h1 imread Load image h1 imshow Show image using Matplotlib h2 Matplotlib expect different order of RGB channel when compare with openCV h2 cvtColor Change channel color h1 imwrite Save the image h1 resize h2 Resize by ratio h2 flip h1 Drawing on image h1 rectangle h1 circle h1 line h1 putText Add text to the image h1 ploylines Draw polygon h1 fillpoly h1 Draw a retangle on dog face h1 Convert RGB to HLS HSV h1 to RGB h1 to HSV h1 to HLS h1 Blending and pasting h1 addWeighted to blend two image h1 overlay small image on top of a large image no blending h2 Numpy reassignment h1 Blend image of different size h1 Create mask h1 bitwise not h1 bitwise or h1 Thresholding h1 threshold h2 THRESH BINARY h2 THRESH BINARY INV h2 THRESH TRUNC h2 THRESH TOZERO h2 THRESH TOZERO INV h1 adaptiveThreshold h3 ADAPTIVE THRESH GAUSSIAN C h1 Blurring and Smoothing h2 Gamma correction to increase or decrease brightness h2 np power h1 filter2D h1 blur h1 GaussianBlur h1 medianBlur h1 bilateralFilter h1 Morphological operator h1 1 Erosion erode h1 Dilation h1 Opening h1 Closing h1 Morphological Gradient h1 Image Gradient h1 Sobel h1 Laplacian Derivatives h1 Histograms h1 calcHist to calculate histogram h1 Creata a mask h1 calcHist with mask h1 Histogram equalization h1 equalizeHist Equalize the histogram h1 equalization for color image h1 Video h1 Object Detection h2 1 Template matching h2 6 methods for comparison h2 2 Corner detection h3 Corner detection algorithm h2 a Harris corner Detection h2 b Shi Tomasi h1 3 Edge detection h2 Canny Edge Detection h1 4 Grid Detection h2 findChessboardCorners h2 findCirclesGrid h1 6 Contours Detection h2 findContours h1 External Counter h1 Internal Counter h1 7 Feature Matching h3 Three method h1 1 Brute force Matching with ORB Descriptors h3 ORB create h1 2 Brute force Matching with SIFT Descriptors and Ratio Test h1 3 FLANN based Matcher h1 9 Watershed Algorithm h3 steps to find contour using image processing technique h1 Find segment using watershed Algorithm h1 10 Face Detection h2 Haar Cascades h3 For examples on live webcam and videos please check it on my GitHub https github com benai9916 openCV in python h2 Do UPVOTE if you liked this kernel ", "stargazers_count": 0, "forks_count": 0, "description": "Feature Matching Three method1. Image Gradient image gradient is a directional change in the intensity or color in the image SobelSobel operators is a joint Gausssian smoothing plus differentiation operation so it is more resistant to noise. Brute force Matching with SIFT Descriptors and Ratio Test3. html gaeb8dd9c89c10a5c63c139bf7c4f5704d Import Library imread Load image Does not throw any error even if we give the wrong file name. FLANN based Matcher 1. load image again write text on the image when we increase the kernel size the blurring become more dense load image again write text on the image gaussianblur load image again write text on the image median blur in another image in above image we can see some noise we will try to remove it by median blur load image again write text on the image function to generate white background and generate text display image create kernel with iteration 4 create a background noisy image mix the text image and the noise image removing noise form the image create a foreground noisy image foreground noise verticle line are more visible horizontal line are more visible capture both horizontal and vetical line threshold morpohological operator load three images raimbow image create mask in the above mask select some portion out of it new image to equalize the histogram of a color image to increase the contrast of an image translate the image to HSV grab the value channel covert HSV to RGB load the full image load the subset of image to match shape of both the image create a copy of image TEMPLATE MATCHNG draw rectangle on the detected area plot and show the image read image covert it to float harris corner just to show the corner we use dialat dilate Load image show image detect corner in the real chess image show image load image canny edge detector find the best threshold value choose lower threshold value to either 0 or 70 of median value whichever is greater upper threshold to either 130 of the median or 255 which ever is small Blur and the apply canny edge detection findChessBoardCorners is specifically work with chess board type image cv2. morphologyEx Closing Closing is reverse of Opening Dilation followed by Erosion. This operation processes the edges while removing the noise. Opening Opening is just another name of erosion followed by dilation. And the closest one is returned. A pixel in the original image either 1 or 0 will be considered 1 only if all the pixels under the kernel is 1 otherwise it is eroded made to zero. It takes the descriptor of one feature in first set and is matched with all other features in second set using some distance calculation. If the ratio is more than 0. RETR_CCOMP extract both interal and external contour external_contour np. Face Detection Haar CascadesThe algorithm needs a lot of positive images images of faces and negative images images without faces to train the classifier. So whatever operations you can do in Numpy you can combine it with OpenCV which increases the number of weapons in your arsenal. shape for i in range len contours if hierarchy 0 i 3 1 cv2. With each window a score R is associated. Draw first 10 matches. Brute force Matching with ORB Descriptors Brute Force matcher is simple. Besides that several other libraries like SciPy Matplotlib which supports Numpy can be used with this. Corner detection algorithm Harris Corner Detection Harris Corner Detector is just a mathematical way of determining which windows produce large variations when moved in any direction. So it increases the white region in the image or size of foreground object increases. bilateralFilter A bilateral filter is used for smoothening images and reducing noise while preserving edges. Grid Detection findChessboardCorners findCirclesGrid 6. steps to find contour using image processing technique1. This is how OpenCV Python works it is a Python wrapper around original C implementation. Laplacian Derivatives Histograms calcHist to calculate histogram Creata a mask calcHist with mask Histogram equalization equalizeHist Equalize the histogram when we equalize the histogram we increase the contrast in the image equalization for color image Video Object Detection 1. Then we need to extract features from it. 8 it means they are rejected. Sort them in the order of their distance. distance good. All the OpenCV array structures are converted to and from Numpy arrays. They are just like our convolutional kernel. html gga3a7850640f1fe1f58fe91a2d7583695dac5babb7dfda59544e3e31ea928f8cb16 2. Here a pixel element is 1 if atleast one pixel under the kernel is 1. It is useful in removing noise. Contours Detection A contour is a curve joining all the continuous points having same color or intensity they represent the shapes of objects found in an image. 0 d7 d1b group__imgproc__misc. And the support of Numpy makes the task easier. Template matching Template matching is a technique for finding areas of an image that are similar to a patch A patch is a small image with certain features. Edge detection Canny Edge Detection apply Gaussian filter to smooth the image in order to remove the noise 4. But another important feature of Python is that it can be easily extended with C C. medianBlur The central element of the image is replaced by the median of all the pixels in the kernel area. Each feature is a single value obtained by subtracting sum of pixels under white rectangle from sum of pixels under black rectangle. The goal of template matching is to find the patch template in an image. html ggaa9e58d2860d4afa658ef70a9b1115576a147222a96556ebc1d948b372bcd7ac59 THRESH_BINARY THRESH_BINARY_INV THRESH_TRUNC THRESH_TOZERO THRESH_TOZERO_INV adaptiveThreshold Adaptive thresholding is the method where the threshold value is calculated for smaller regions and therefore there will be different threshold values for different regions. findContours External Counter Internal Counter 7. It is the simplest form of object detection we should have the subset of the same image to detect the object 6 methods for comparison https docs. Here we use the function cv2. jpg attachment haar_features. It will find a good matching but not necessarily the best possible one. This feature helps us to write computationally intensive codes in C C and create a Python wrapper for it so that we can use these wrappers as Python modules. 0 d4 d15 group__videoio__flags__base. shape external_contour. But in some cases because of factors such as noise the second closest match may seem to be closer to the first. This gives us two advantages first our code is as fast as original C C code since it is the actual C code working in background and Second it is very easy to code in Python. This algorithm is useful in segmenting images into background and foreground. For this haar features shown in below image are used. ration test to check if the first match and the second match are close to each other or not less distance better match for match1 match2 in matches if match1. Find contours Find segment using watershed Algorithm 10. append match1 FLANN call function to show image apply otsu method in threshold noise removal option good way to reduce noise sure background area DISTANCE TRANSFORM to seperate the coins close to black will fade way and closer to white will become brighter Finding unknown region Marker labelling Add one to all labels so that sure background is not 0 but 1 Now mark the region of unknown with zero In this case we are not able to dtect the eys because the color of the eyes is not learly visible. Brute force Matching with SIFT Descriptors and Ratio TestSIFT Scale Invariant Feature Transform The SIFT keypoints between two images are matched by identifying their nearest neighbors. Morphological operator Morphological transformations are some simple operations based on the image shape. OpenCVCompared to other languages like C C Python is slower. Corner detection A corner can be interpreted as the junction of two edges where an edge is a sudden change in image brighteness. If we print the value and we get None shows something is wrong imshow Show image using Matplotlib Matplotlib expect different order of RGB channel when compare with openCV MATPLOTLIB RGB RED GREEN BLUE OPENCV BGR BLUE GREEN RED cvtColor Change channel color imwrite Save the image resize Resize by ratio flip Drawing on image rectangle circle line putText Add text to the image ploylines Draw polygon fillpoly Draw a retangle on dog face Convert RGB to HLS HSV to RGB to HSV to HLS Blending and pasting addWeighted to blend two image only work image with the same size overlay small image on top of a large image no blending Numpy reassignment Blend image of different size Create mask bitwise_not bitwise_or Thresholding threshold is used to convert grayscale images to binary image. It is normally performed on binary images. Each channel of a multi channel image is processed independently. It needs two inputs one is our original image second one is called structuring element or kernel which decides the nature of operation. Gamma correction to increase or decrease brightness Gamma correction apply to an image to make it brighter or darker depending on gamma value np. Dilation It is just opposite of erosion. Brute force Matching with ORB Descriptors2. a Harris corner Detection b Shi Tomasi 3. In this case we compute the ratio of closest distance to the second closest distance and check if it is above 0. drawContours external_contour contours i 255 1 plt. Morphological GradientIt is the difference between dilation and erosion of an image. Erosion erode The basic idea of erosion is just like soil erosion only it erodes away the boundaries of foreground object Always try to keep foreground in white. imshow external_contour create orb instance Create a matching object Match descriptors. Shi Tomsi Corner Detection If we re scanning the image with a window just as we would with a kernel and we notice that there is an area where there s a major change no matter in what direction we actually scan then we have a good intuition that there s probably a corner there. org master df dfb group__imgproc__object. Watershed Algorithm A marker based watershed algorithm where you specify which are all valley points are to be merged and which are not. threshold thresholding is the simplest method of segmenting imageshttps docs. jpg We need to load pre train haar cascades classifier For examples on live webcam and videos please check it on my GitHub https github. power filter2D we can play around with the kernel to see different type of blur in the image blur The function smooths an image using the kernel GaussianBlur The Gaussian filter is a low pass filter that reduce the high frequency components. So what does it do The kernel slides through the image as in 2D convolution. Based on this score you can figure out which ones are corners and which ones are not. ADAPTIVE_THRESH_GAUSSIAN_C Blurring and Smoothing Blurring and smoothing often combine with edge detection In blurring we simple reduce the edge content and makes the transition form one color to the other very smooth. FLANN based MatcherFLANN meaning Fast Library for Approximate Nearest Neighbors will be much faster but will find an approximate nearest neighbors. It is useful in closing small holes inside the foreground objects or small black points on the object. It is an interactive image segmentation. com benai9916 openCV in python Do UPVOTE if you liked this kernel fix the figure size for matplotlin load wrong image wont throw error load correct image convert to RGB Load the image in gray scale since by default it is not in grayscale we will covert it into gray scale flip the image print another rectange cricle Fill the circle or rectange by 1 line choose font new blank image it is in two dimension covert it into three dimension reshape fillpoly shape of both the image resize both the image so that we can blend load image again make img_2 very small assing large image and small image to a variable overy lay small image on the big image load image again make img_2 small in size img_1 shape y axis 1401 x 934 x_offset x of img_1x x axis of img_2 create an ROI Region of interest check rows columns shape grab the ROI get the gray scale version of the image get pure white of mask but the mask contain no channel covert it to 3 channel which part of the large image do we want to blend it is call Region of interest ROI function to show big picture make the figure size big use binary threshold to make pic either white or black call function to show image blend cross_thresh and th2 load image function display image functio call the functions gamma value load image write text on the image define a kernel we are manually choosing value we can play around with the kernel to see different type of blur in the image 1 representing the depth of the output image. ", "id": "benai9916/opencv", "size": "9426", "language": "python", "html_url": "https://www.kaggle.com/code/benai9916/opencv", "git_url": "https://www.kaggle.com/code/benai9916/opencv", "script": "linear_model sklearn numpy matplotlib.pyplot bg_img_text bg_load_img load_image display_img adj_detect_face big_fig ", "entities": "(('which', 'edge detection chess board type image ever small apply canny specifically cv2'), 'write') (('which', 'this'), 'use') (('we', 'comparison https docs'), 'be') (('joint Gausssian smoothing it', 'more noise'), 'be') (('algorithm', 'background'), 'be') (('Closing morphologyEx Closing', 'Erosion'), 'be') (('otherwise it', 'zero'), 'consider') (('task', 'Numpy'), 'make') (('Morphological GradientIt', 'image'), 'be') (('Face Detection Haar CascadesThe algorithm', 'classifier'), 'need') (('transition', 'other very smooth'), 'combine') (('score R', 'window'), 'associate') (('OpenCV array structures', 'Numpy arrays'), 'convert') (('we', 'output image'), 'com') (('haar features', 'image'), 'use') (('structuring which', 'operation'), 'be') (('It', 'distance calculation'), 'take') (('Brute force', 'ORB Descriptors Brute Force matcher'), 'be') (('patch', 'small certain features'), 'be') (('threshold where value', 'threshold therefore different different regions'), 'ggaa9e58d2860d4afa658ef70a9b1115576a147222a96556ebc1d948b372bcd7ac59') (('it', '0'), 'compute') (('even we', 'file wrong name'), 'imread') (('So it', 'foreground object increases'), 'increase') (('ones', 'score'), 'figure') (('Find contours', 'Algorithm'), 'find') (('RETR_CCOMP', 'contour external_contour interal np'), 'extract') (('central element', 'kernel area'), 'medianBlur') (('kernel', '2D convolution'), 'do') (('operation', 'noise'), 'process') (('C C Python', 'other languages'), 'opencvcompare') (('Edge Canny Edge Detection', 'noise'), 'detection') (('threshold thresholding', 'imageshttps simplest docs'), 'be') (('we', 'color image Video Object Detection'), 'calchist') (('They', 'just convolutional kernel'), 'be') (('goal', 'image'), 'be') (('away boundaries', 'white'), 'erode') (('keypoints', 'nearest neighbors'), 'force') (('It', 'small black object'), 'be') (('create orb instance', 'object Match matching descriptors'), 'imshow') (('it', 'gamma value np'), 'apply') (('channel', 'channel multi image'), 'process') (('it', 'Python C original implementation'), 'be') (('which', 'arsenal'), 'do') (('pass low that', 'frequency high components'), 'filter2D') (('Create mask Thresholding threshold', 'binary image'), 'expect') (('classifier', 'GitHub https github'), 'need') (('Then we', 'it'), 'need') (('ration first match', 'matches'), 'test') (('meaning', 'much approximate nearest neighbors'), 'be') (('it', 'C easily C.'), 'be') (('color', 'eyes'), 'call') (('second closest match', 'first'), 'seem') (('It', 'normally binary images'), 'perform') (('feature', 'black rectangle'), 'be') (('Python', 'wrappers'), 'help') (('actually then we', 'good intuition'), 'Tomsi') (('one pixel', 'kernel'), 'be') (('operator Morphological Morphological transformations', 'image simple shape'), 'be') (('they', 'image'), 'be') (('windows', 'when direction'), 'algorithm') (('bilateral filter', 'edges'), 'bilateralfilter') (('Second it', 'very Python'), 'give') (('Opening', 'dilation'), 'be') (('It', 'good matching'), 'find') (('Grid Detection findChessboardCorners', '6'), 'findcirclesgrid') (('where edge', 'image sudden brighteness'), 'detection') ", "extra": "['test']", "label": "Perfect_files", "potential_description_queries": ["algorithm", "append", "apply", "area", "array", "background", "basic", "become", "best", "binary", "blend", "board", "calculate", "call", "canny", "case", "channel", "check", "choose", "circle", "classifier", "close", "closing", "code", "color", "combine", "compare", "comparison", "compute", "contain", "content", "contour", "contrast", "convert", "convolutional", "copy", "correct", "correction", "create", "curve", "default", "define", "depth", "detect", "detected", "detection", "detector", "df", "difference", "dilation", "dimension", "direction", "display", "distance", "draw", "edge", "equalize", "erosion", "error", "even", "external", "extract", "face", "faster", "feature", "figure", "file", "filter", "find", "fix", "flip", "float", "foreground", "form", "found", "frequency", "function", "gamma", "generate", "grab", "gradient", "gray", "grayscale", "hierarchy", "high", "histogram", "idea", "image", "imread", "imshow", "increase", "instance", "intensity", "interactive", "interest", "intuition", "iteration", "kernel", "len", "line", "load", "lot", "lower", "major", "mask", "match", "matching", "meaning", "median", "method", "my", "name", "nature", "nearest", "need", "negative", "new", "no", "noise", "not", "number", "object", "operation", "operator", "option", "order", "otsu", "out", "output", "overlay", "part", "patch", "picture", "pixel", "plot", "polygon", "positive", "power", "pre", "print", "processing", "python", "range", "ratio", "re", "read", "reduce", "region", "remove", "reshape", "resize", "reverse", "scale", "scan", "score", "second", "segment", "select", "set", "several", "shape", "similar", "single", "size", "smooth", "something", "subset", "sum", "support", "task", "technique", "template", "test", "text", "threshold", "thresholding", "through", "train", "translate", "try", "type", "under", "upper", "value", "variable", "version", "watershed", "while", "window", "work", "wrapper", "write"], "potential_description_queries_len": 192, "potential_script_queries": ["numpy", "sklearn"], "potential_script_queries_len": 2, "potential_entities_queries": ["array", "board", "convolutional", "high", "mask", "nearest", "type"], "potential_entities_queries_len": 7, "potential_extra_queries": [], "potential_extra_queries_len": 0, "all_components_potential_queries_len": 194}