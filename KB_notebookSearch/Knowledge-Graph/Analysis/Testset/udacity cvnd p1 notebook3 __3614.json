{"name": "udacity cvnd p1 notebook3 ", "full_name": " h2 Face and Facial Keypoint detection h4 Select an image h2 Detect all faces in an image h2 Loading in a trained model h2 Keypoint detection h3 TODO Transform each detected face into an input Tensor h3 TODO Detect and display the predicted keypoints ", "stargazers_count": 0, "forks_count": 0, "description": "1 d7 d8b tutorial_py_face_detection. You may find it useful to consult to transformation code in data_load. An example of face detection on a variety of images is shown below. You should end up with an image like the following with facial keypoints that closely match the facial features on each individual face load in color image for face detection switch red and blue color channels by default OpenCV assumes BLUE comes first not RED as in many images plot the image load in a haar cascade classifier for detecting frontal faces run the detector the output here is an array of detections the corners of each detection box if necessary modify these parameters until you successfully identify every face in a given image make a copy of the original image to plot detections on loop over the detected faces mark the image where each face is found draw a rectangle around each detected face you may also need to change the width of the rectangle drawn depending on image resolution can use the below import should you choose to initialize the weights of your Net from models import Net As an example you ve been given a convolutional layer which you may but don t have to change 1 input image channel grayscale 32 output channels feature maps 5x5 square convolution kernel self. This step will be similar to the data_transform you created and applied in Notebook 2 whose job was tp rescale normalize and turn any iimage into a Tensor to be accepted as input to your CNN. The ouput should be the predicted the facial keypoints. html as an optional exercise in using Haar detectors. Rescale the detected face to be the expected square size for your CNN 224x224 suggested 4. fc1_bn x a modified x having gone through all the layers of your model should be returned image is grayscale loop over the detected faces from your haar cascade Select the region of interest that is the face in the image. TODO Transform each detected face into an input TensorYou ll need to perform the following steps for each detected face 1. dropout2 x x self. BatchNorm1d 1024 self. Face and Facial Keypoint detectionAfter you ve trained a neural network to detect facial keypoints you can then apply this network to any image that includes faces. Hint The sizes of faces detected by a Haar detector and the faces your network has been trained on are of different sizes. BatchNorm1d 1024 x self. You can even add eye detections https docs. Detect all faces in an imageNext you ll use one of OpenCV s pre trained Haar Cascade classifiers all of which can be found in the detector_architectures directory to find any faces in your selected image. Detect all the faces in an image using a face detector we ll be using a Haar Cascade detector in this notebook. These keypoints will need to be un normalized for display and you may find it helpful to write a helper function like show_keypoints. In the next python cell we load in required libraries for this section of the project. First load your best model by its filename. Reshape the numpy image into a torch image. dropout4 x x self. Pre process those face images so that they are grayscale and transformed to a Tensor of the input size that your net expects. dropout3 x x self. dropout5 x Prep for Linear layer x self. Select an image Select an image to perform facial keypoint detection on you can select any image of faces in the images directory. 1 maxpooling layers multiple conv layers fully connected layers and other layers such as dropout or batch normalization to avoid overfitting self. The neural network expects a Tensor of a certain size as input and so to detect any face you ll first have to do some pre processing. TODO Detect and display the predicted keypointsAfter each face has been appropriately converted into an input Tensor for your network to see as input you can apply your net to each face. Keypoint detectionNow we ll loop over each detected face in an image again only this time you ll transform those faces in Tensors that your CNN can accept as input images. In the code below we loop over each face in the original image and draw a red square on each face in a copy of the original image so as not to modify the original. Convert the face from RGB to grayscale2. If you find that your model is generating keypoints that are too small for a given face try adding some padding to the detected roi before giving it as input to your model. Normalize the grayscale image so that its color range falls in 0 1 instead of 0 255 3. Loading in a trained modelOnce you have an image to work with and again you can select any image of faces in the images directory the next step is to pre process that image and feed it into your CNN facial keypoint detector. Use your trained model to detect facial keypoints on the image. dropout1 x x self. py to help you perform these processing steps. ", "id": "capallen/udacity-cvnd-p1-notebook3", "size": "3614", "language": "python", "html_url": "https://www.kaggle.com/code/capallen/udacity-cvnd-p1-notebook3", "git_url": "https://www.kaggle.com/code/capallen/udacity-cvnd-p1-notebook3", "script": "torch.nn.functional torch.nn.init __init__ forward torch.nn numpy matplotlib.pyplot models Net show_all_keypoints Net(nn.Module) matplotlib.image ", "entities": "(('you', 'face'), 'convert') (('Select', 'images directory'), 'select') (('we', 'notebook'), 'detect') (('Rescale', '224x224 4'), 'suggest') (('we', 'original'), 'loop') (('Haar Cascade trained all', 'selected image'), 'use') (('you', 'processing steps'), 'py') (('CNN', 'input images'), 'transform') (('it', 'show_keypoints'), 'need') (('conv 1 maxpooling layers multiple layers', 'self'), 'connect') (('sizes', 'are different sizes'), 'Hint') (('that', 'model'), 'try') (('we', 'project'), 'load') (('2 job', 'CNN'), 'be') (('you', 'pre first processing'), 'expect') (('it', 'data_load'), 'find') (('next step', 'keypoint CNN facial detector'), 'have') (('TensorYou', 'detected face'), 'transform') (('You', 'eye detections https even docs'), 'add') (('that', 'image'), 'fc1_bn') (('color range', '255 1 instead 0 3'), 'normalize') (('that', 'faces'), 'face') (('input image 1 channel', 'which'), 'end') (('net', 'that'), 'process') (('example', 'images'), 'show') ", "extra": "", "label": "No_extra_files", "potential_description_queries": ["apply", "array", "batch", "best", "box", "cell", "channel", "choose", "classifier", "code", "color", "conv", "convolution", "convolutional", "copy", "default", "detect", "detected", "detection", "detector", "directory", "display", "draw", "end", "even", "every", "exercise", "expected", "eye detections https even docs", "eye", "face", "feature", "feed", "find", "following", "found", "function", "grayscale", "help", "helper", "image", "import", "individual", "initialize", "input", "interest", "job", "kernel", "layer", "load", "loop", "match", "model", "multiple", "need", "network", "neural", "next", "normalization", "normalize", "normalized", "not", "numpy", "output", "overfitting", "padding", "perform", "plot", "pre", "processing", "py", "python", "range", "region", "rescale", "resolution", "roi", "run", "section", "select", "selected", "similar", "size", "square", "step", "those", "through", "time", "torch", "transform", "transformation", "try", "turn", "until", "up", "width", "work", "write"], "potential_description_queries_len": 98, "potential_script_queries": ["forward", "nn", "torch"], "potential_script_queries_len": 3, "potential_entities_queries": ["image"], "potential_entities_queries_len": 1, "potential_extra_queries": [], "potential_extra_queries_len": 0, "all_components_potential_queries_len": 99}