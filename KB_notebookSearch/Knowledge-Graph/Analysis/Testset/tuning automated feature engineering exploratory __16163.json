{"name": "tuning automated feature engineering exploratory ", "full_name": " h1 Introduction Tuning Automated Feature Engineering h3 Read in Data and Create Smaller Datasets h1 Properly Representing Variable Types h1 Time Variables h3 Replace Outliers h3 Plot for a sanity check h4 Bureau Balance h4 Previous Applications h4 Previous Credit and Cash h4 Installments Payments h1 Applying Featuretools h3 Entities h3 Relationships h2 Time Features h1 Interesting Values h1 Seed Features h1 Create Custom Feature Primitives h3 NormalizedModeCount and LongestSeq h3 MostRecent h1 Putting it all Together h2 Remove Features h1 Conclusions ", "stargazers_count": 0, "forks_count": 0, "description": "I m still working on figuring out the most useful features to build by reading through other kernels finding features and figuring out how to recreate and build upon those in featuretools. However one thing we can do is use the built in featuretools selection function to remove https docs. Using the default feature primitives in the basic notebook did improve our score but to do better we will need some more advanced methods. These are user defined features that we provide to deep feature synthesis that can then be built on top of where possible. NormalizedModeCount and LongestSeqAs an example we will make three features building on code from the featuretools GitHub https github. One of the features is MEAN previous. MostRecentThe final custom feature will be MOSTRECENT. Credit Bureau refers to any other credit organization besides Home Credit. We can compare the distribution of this feature to the MEAN previous. To actually run this on the entire dataset we can take the code here put it in a script and then use more computational resources. It has two date offset columns DAYS_INSTALMENT number of days before current application at Home Credit that previous installment was supposed to be paid DAYS_ENTRY_PAYMENT number of days before current application at Home Credit that previous installment was actually paidBy now the process should be familiar convert to timedeltas and then make time columns. This can help to optimize the dfs procedure and the chunk_size can have a significant effect on the run time https docs. We will call this the update date bureau_credit_update_date. We want to be careful because the index of the dataframe is the identifying column so we should keep the index. DAYS_CREDIT_UPDATE Number of days before current application at Home Credit that the most recent information about the previous credit arrived. Reading through discussions others replaced this number with np. This is one area where we can apply domain knowledge to feature creation. pandas and numpy for data manipulation automated feature engineering Filter out pandas warnings Read in the datasets and limit to the first 1000 rows sorted by SK_ID_CURR This allows us to actually see the results in a reasonable amount of time Iterate through the columns and record the Boolean columns If column is a number with only two values encode it as a Boolean Record ordinal variables Record boolean variables in the previous data Replace all the day outliers Establish a starting date for all applications at Home Credit Convert to timedelta in days Create the date columns Set up default plot styles Drop the time offset columns Convert to timedelta Make a date column Select one loan and plot Convert to timedeltas in days Make date columns Drop the time offset columns Convert to timedelta objects Make a date column Make a date column Select on loan and plot Conver to time delta object Create time column and drop Select one loan and plot Make an entityset Entities with a unique index Entities that do not have a unique index Relationship between app and bureau Test Relationship between app and bureau Relationship between bureau and bureau balance Relationship between current app and previous apps Test Relationship between current app and previous apps Relationships between previous apps and cash installments and credit Add in the defined relationships Print out the EntitySet Assign interesting values Calculate the features with intereseting values Plot of client type when contract was approved Plot of client type where contract was refused Late Payment seed feature Rename the feature DFS with seed features Create a feed representing whether the loan is past due DFS with specified seed feature Count occurence of each value Find the mode Divide the occurences of mode by the total occurrences Function from https codereview. For example in bureau the DAYS_CREDIT column represents How many days before current application did client apply for Credit Bureau credit. py Sort the values by timestamps reversed Return the most recent occurence DFS with custom feature Run and create the features Run and create the features Remove low information features Save the feature matrix to a csv. Any ideas would be much appreciated This work draws heavily on the featuretools documentation https docs. The resulting column of dates can be used as a time_index. As an example we can create a seed feature that determines whether or not a payment was late. To use interesting values we assign them to the variable and then specify the where_primitives in the dfs call. Some of these are Boolean flags only 1 or 0 and two columns are ordinal ordered discrete. remove_low_information_features. We also want to avoid making any features with the testing data so we pass in ignore_entities app_test. Read in Data and Create Smaller DatasetsWe will limit the data to 1000 rows because automated feature engineering is computationally intensive work. py by the time_index. We will call this the application date bureau_credit_application_date and make it the time_index of the entity. EntitiesWhen creating the entities we specify the index the time_index if present and the variable_types if they need to be specified. html columns that only have one unique value or have all null values. Interesting ValuesAnother method we can use in featuretools is interesting values. As with many aspects of machine learning feature creation is largely an empirical and iterative procedure. com generated featuretools. Time VariablesTime can be a crucial factor in many datasets because behaviors change over time and therefore we want to make features to reflect this. These four columns represent different offsets DAYS_CREDIT Number of days before current application at Home Credit client applied for loan at other financial institution. org wiki Feature_selection is an entire topic to itself. All the time offset are measured from the current application at Home Credit and are measured in months or days. However in cases where there are multiple different time columns it might be useful to know the most recent value with respect to all of the times. This shows the average term of previous credit on previous loans conditioned on the previous loan being approved. For example we can create new features that are conditioned on the value of NAME_CONTRACT_STATUS in the previous dataframe. First we can establish an arbitrary date and then convert the time offset in months into a Pandas timedelta object. Previous ApplicationsThe previous dataframe holds previous applications at Home Credit. If we don t do this Pandas will not be able to convert into a timedelta and throws an error that the number is too large. Only building a model and training it with the features will help us determine the answer. Although we do not know the actual application date if we assume a starting application date that is the same for all clients then we can convert the MONTHS_BALANCE into a datetime. Previous Credit and CashThe credit_card_balance and POS_CASH_balance each have a MONTHS_BALANCE column with the month offset. However in this notebook we will not make any features by hand but rather let featuretools develop useful features for us. com Featuretools featuretools blob master featuretools primitives aggregation_primitives. Later we can refactor this code into functions and put it in a script to run on a more powerful machine. These methods include Properly representing variable types Creating and using time variables Setting interesting values of variables Creating seed features Building custom primitivesReading through the discussion around this competition and working through some of the top kernels intricate feature engineering is a must. There are no explicit datetimes in the data but there are relative time offsets. For example a client might be taking out larger and larger loans over time which could be an indicator that they are about to default or they could have a run of missed payments but then get back on track. This time when we make the dfs function call we need to pass in the seed_features argument. If we were doing manual feature engineering we might want to create new columns such as by subtracting DAYS_CREDIT_ENDDATE from DAYS_CREDIT to get the planned length of the loan in days or subtracting DAYS_CREDIT_ENDDATE from DAYS_ENDDATE_FACT to find the number of days the client paid off the loan early. The DAYS_INSTALMENT will serve as the time_index. In other words for a client with 5 total bureau_balance observations where 4 of the STATUS were X the value of the NormalizedModeCount would be 0. Plot for a sanity checkTo make sure the conversion went as planned let s make a plot showing the distribution of loan lengths. To make date columns from the timedelta we simply add the offset to the start date. To build the custom feature primitive I adapted the existing TREND primitive code here https github. A positive value indicates that the loan size for the client is increasing over time. To test whether this function works as intended we can compare the most recent variable of CREDIT_TYPE ordered by two different dates. We will now do the same operation applied to the test set. Let s visualize one of these new variables. Each stat will be calculated for the specified interesting values which can be useful when we know that there are certain indicators that are of greater importance in the data. com automated_feature_engineering primitives. com Featuretools featuretools. We can look at the trend in credit size over time. Reading through the discussions other people had noticed this as well. com a 15095 Set the longest element Iterate through the iterable DFS with custom features Building on the Trend Aggregation Primitive Copied from https github. com and the featuretools GitHub repository https github. We will explore a few different methods for improving the set of features and incorporating domain knowledge into the final dataset. Throughout this notebook we will pass in a chunk_size to the dfs call which specifies the number of rows if an integer or the fraction or rows to use in each chunk if a float. This simply returns the most recent value of a discrete variable with respect to time columns in a dataframe. Because entities in the entityset are sorted by the time_index this will return the value that occurs the most number of times in a row with respect to time. It looks as if there are a number of loans that are unreasonably long. The second custom feature will record the longest consecutive run of a discrete variable. com JYLFamily Home_Credit_Default_Risk blob master 20180603 FeaturesV2 ApplicationTestFeatures. We will create an entityset named clients much as before but now we have time variables that we can use. Seed FeaturesAn additional extension to the default aggregations and transformations is to use seed features https docs. Replace OutliersThere are a number of day offsets that are recorded as 365243. Time FeaturesLet s look at some of the time features we can make from the new time variables. Therefore the built in aggregation primitive LAST calculates the most recent value based on the time index. There are also two ordinal variables in the app data the rating of the region with and without the city. This will be more as an exploration of the capabilities of featuretools than a complete implementation. com automated_feature_engineering dfs_usage_tips. Another seed feature we can use is whether or not a previous loan at another institution was past due. Create Custom Feature PrimitivesIf we are not satisfied with the existing primitives in featuretools we can write our own https docs. We also should align the training and testing dataframes to make sure they have the same columns. There are a number of time offset columns in this dataset DAYS_DECISION number of days before current application at Home Credit that decision was made about previous application. This is the number of months before the current application at Home Credit of the previous application record. com guides performance. The first NormalizedModeCount builds upon the Mode function by returning the fraction of total observations in a categorical feature that the model makes up. We would not want to calculate values like the year or month since we choose an arbitrary starting date. Here we will use a chunk size equal to the number of rows in the data so all the results will be calculated in one pass. Installments Payments The installments_payments data contains information on each payment made on the previous loans at Home Credit. For client 100002 the most recent type of credit was Credit card if we order by the application date but Consumer credit if we order by the end date of the loan. Applying FeaturetoolsWe can now start making features using the time columns. The previous data also has two Boolean variables. DAYS_FIRST_DRAWING number of days before current application at Home Credit that first disbursement was made DAYS_FIRST_DUE number of days before current application at Home Credit that first due was suppoed to be DAYS_LAST_DUE_1ST_VERSION number of days before current application at Home Credit that first was DAYS_LAST_DUE number of days before current application at Home Credit of last due date of previous application DAYS_TERMINATION number of days before current application at Home Credit of expected terminationLet s convert all these into timedeltas in a loop and then make time columns. The following code has been adapted from a script on GitHub https github. The idea is to record not only the most common value but also the relative frequency of the most common value compared to all observations. This will be the time_index of the data. html defining custom primitives. This can then be treated as a relative time that we can use to find trends or identify the most recent value of a variable. Remove Features Feature selection https en. These will represent the time_index of the data. We will call this the ending date bureau_credit_end_date DAYS_ENDDATE_FACT For closed credits the number of days before current application at Home Credit that credit at other financial institution ended. Doing the calculations separately should prevent leakage from the testing data into the training data. These will be aggregation primitives where the function takes in an array of values and returns a single value. html specifying list of aggregation functions. CNT_PAYMENT WHERE NAME_CONTRACT_STATUS Approved. com willkoehrsen applied automated feature engineering basics applied to the Home Credit Default Risk competition. Introduction Tuning Automated Feature EngineeringIn this notebook we will expand upon the basic automated feature engineering https www. Whether this is actually useful knowledge is hard to say Putting it all TogetherFinally we can run deep feature synthesis with the time variables with the correct specified categorical variables with the interesting features with the seed features and with the custom features. RelationshipsNot surprisingly the relationships between tables has not changed since the previous implementation. To tell featuretools to treat these as Boolean variables we need to pass in the correct datatype using a dictionary mapping variable_name variable_type. LongestSeq takes in an array of discrete values and returns the element that appears the most consecutive times. When we re done we probably want to save the results to a csv. We will call this the closing date bureau_credit_close_date. Specifying interesting values will calculate new features conditioned on values of existing features. We could use the feature importances from the model to determine the most relevant features perform feature selection and then go through another round of feature synthesis with a new set of of primitives seed features and interesting features. These features could be completely useless or they may be helpful. Based on the most important features returned by a model we can create new interesting features. com Featuretools featuretools blob master featuretools entityset entity. Conclusions In this notebook we explored some of the advanced functionality in featuretools including Time Variables allow us to track trends over time Interesting Variables condition new features on values of existing features Seed Features define new features manually that featuretools will then build on top of Custom feature primitives design any transformation or aggregation feature that can incorporate domain knowledgeWe can use these methods to encode domain knowledge about a problem into our features or create features based on what others have found useful. CNT_PAYMENT WHERE NAME_CONTRACT_STATUS Canceled to see how these loans differ. The next step from here would be to run the script on the entire dataset then use the features for modeling. DAYS_CREDIT_ENDDATE Number of days of credit remaining at time of client s application at Home Credit. We also will drop the time offset columns. At this point we will just leave in the outliers. This is an extremely powerful method that lets us expand the capabilities of featuretools. Because these times are relative and not absolute we are only interested in values that show change over time such as trend or cumulative sum. Bureau BalanceThe bureau balance dataframe has a MONTHS_BALANCE column that we can use as a months offset. Properly Representing Variable TypesThere are a number of columns in the app dataframe that are represented as integers but are really discrete variables that can only take on a limited number of features. When we create an entity featuretools will sort the entity https github. ", "id": "willkoehrsen/tuning-automated-feature-engineering-exploratory", "size": "16163", "language": "python", "html_url": "https://www.kaggle.com/code/willkoehrsen/tuning-automated-feature-engineering-exploratory", "git_url": "https://www.kaggle.com/code/willkoehrsen/tuning-automated-feature-engineering-exploratory", "script": "featuretools longest_repetition collections seaborn numpy matplotlib.pyplot featuretools.variable_types make_agg_primitive normalized_mode_count most_recent timedelta pandas featuretools.primitives selection Counter replace_day_outliers datetime AggregationPrimitive ", "entities": "(('where 4', 'NormalizedModeCount'), 'be') (('most recent information', 'previous credit'), 'Number') (('previous loan', 'institution'), 'be') (('I', 'featuretools'), 'work') (('we', 'months'), 'have') (('Seed FeaturesAn additional extension', 'seed features https docs'), 'be') (('resulting column', 'time_index'), 'use') (('three features', 'featuretools'), 'NormalizedModeCount') (('we', 'new interesting features'), 'base') (('we', 'two different dates'), 'test') (('others', 'np'), 'replace') (('We', 'MEAN'), 'compare') (('we', 'mapping variable_name dictionary variable_type'), 'tell') (('decision', 'previous application'), 'be') (('feature automated engineering', '1000 rows'), 'limit') (('client', 'Credit Bureau credit'), 'represent') (('surprisingly relationships', 'previous implementation'), 'RelationshipsNot') (('using', 'feature intricate engineering'), 'include') (('they', 'time_index'), 'EntitiesWhen') (('rather featuretools', 'us'), 'make') (('that', '365243'), 'be') (('com Featuretools', 'blob master featuretools'), 'featuretool') (('Therefore built', 'time index'), 'calculate') (('results', 'one pass'), 'use') (('idea', 'observations'), 'be') (('time offset', 'months'), 'measure') (('Previous ApplicationsThe previous dataframe', 'Home Credit'), 'hold') (('Consumer we', 'loan'), 'be') (('most relevant features', 'primitives seed features'), 'use') (('We', 'this'), 'call') (('These', 'data'), 'represent') (('Later we', 'more powerful machine'), 'refactor') (('we', 'ignore_entities app_test'), 'want') (('that', 'time'), 'return') (('s', 'new variables'), 'let') (('much work', 'featuretools documentation https heavily docs'), 'appreciate') (('we', 'seed_features argument'), 'need') (('DAYS_CREDIT Number', 'other financial institution'), 'represent') (('actually now process', 'time then columns'), 'have') (('we', 'feature engineering https basic automated www'), 'introduction') (('really discrete that', 'features'), 'be') (('TogetherFinally we', 'custom features'), 'be') (('We', 'time'), 'look') (('next step', 'modeling'), 'be') (('following code', 'GitHub https github'), 'adapt') (('custom second feature', 'discrete variable'), 'record') (('Boolean only 1 two columns', 'these'), 'be') (('credit', 'other financial institution'), 'call') (('that', 'time then columns'), 'number') (('features', 'this'), 'be') (('that', 'loans'), 'look') (('we', 'starting arbitrary date'), 'want') (('we', 'featuretools'), 'be') (('we', 'csv'), 'want') (('that', 'most consecutive times'), 'take') (('we', 'start date'), 'add') (('that', 'such trend'), 'be') (('org wiki Feature_selection', 'entire itself'), 'be') (('others', 'what'), 'explore') (('we', 'variable'), 'treat') (('then we', 'datetime'), 'know') (('com willkoehrsen', 'Home Credit Default Risk competition'), 'apply') (('First we', 'Pandas timedelta object'), 'establish') (('certain that', 'data'), 'calculate') (('us', 'featuretools'), 'be') (('blob master', 'entityset entity'), 'featuretool') (('Doing', 'training data'), 'prevent') (('loan size', 'time'), 'indicate') (('we', 'then more computational resources'), 'take') (('This', 'dataframe'), 'return') (('client', 'loan'), 'do') (('better we', 'more advanced methods'), 'need') (('they', 'then back track'), 'take') (('create', 'entity https github'), 'sort') (('Previous each', 'month offset'), 'Credit') (('other people', 'this'), 'notice') (('I', 'existing TREND primitive code'), 'adapt') (('they', 'same columns'), 'align') (('we', 'dfs call'), 'assign') (('Specifying', 'existing features'), 'calculate') (('we', 'https own docs'), 'primitivesif') (('us', 'answer'), 'help') (('This', 'time https run docs'), 'help') (('This', 'complete implementation'), 'be') (('time where multiple different it', 'times'), 'be') (('s', 'loan lengths'), 'make') (('DAYS_INSTALMENT', 'time_index'), 'serve') (('we', 'time new variables'), 'look') (('we', 'that'), 'create') (('one where we', 'creation'), 'be') (('we', 'just outliers'), 'leave') (('application date it', 'entity'), 'call') (('model', 'categorical feature'), 'build') (('Applying FeaturetoolsWe', 'time columns'), 'start') (('We', 'time offset also columns'), 'drop') (('We', 'final dataset'), 'explore') (('payment', 'seed feature'), 'create') (('This', 'application previous record'), 'be') (('identifying so we', 'index'), 'want') (('which', 'chunk'), 'pass') (('We', 'test set'), 'do') (('that', 'then top'), 'be') (('installments_payments data', 'Home Credit'), 'payment') (('py Sort', 'csv'), 'reverse') (('Credit Bureau', 'Home Credit'), 'refer') (('number', 'error'), 'be') (('previous data', 'also two Boolean variables'), 'have') (('html that', 'null values'), 'column') (('previous loan', 'previous loans'), 'show') (('aggregation where function', 'single value'), 'be') (('mode', 'https codereview'), 'automate') (('that', 'previous dataframe'), 'create') (('we', 'https docs'), 'be') ", "extra": "['organization', 'test', 'procedure']", "label": "Perfect_files", "potential_description_queries": ["absolute", "advanced", "application", "apply", "area", "array", "assign", "average", "balance", "basic", "blob", "boolean", "build", "calculate", "call", "categorical", "choose", "chunk", "client", "closing", "code", "column", "compare", "competition", "condition", "conversion", "convert", "correct", "could", "create", "creation", "credit", "current", "custom", "data", "dataframe", "dataset", "date", "day", "decision", "default", "define", "develop", "dictionary", "discrete", "distribution", "domain", "drop", "effect", "encode", "end", "engineering", "entity", "equal", "error", "expand", "expected", "explore", "extension", "factor", "feature", "feed", "final", "find", "following", "found", "frequency", "function", "generated", "hand", "help", "idea", "importance", "improve", "include", "including", "index", "institution", "integer", "knowledge", "learning", "leave", "length", "let", "list", "loan", "longest", "look", "loop", "manual", "mapping", "matrix", "method", "might", "mode", "model", "month", "most", "multiple", "need", "new", "next", "no", "not", "notebook", "null", "number", "numpy", "object", "offset", "operation", "optimize", "order", "ordered", "organization", "out", "past", "people", "perform", "plot", "point", "positive", "present", "prevent", "problem", "procedure", "provide", "py", "rating", "re", "reading", "record", "region", "relative", "remove", "repository", "return", "row", "run", "save", "score", "script", "second", "selection", "set", "single", "size", "sort", "start", "step", "term", "test", "testing", "those", "through", "time", "time_index", "timedelta", "topic", "total", "track", "training", "transformation", "trend", "type", "unique", "up", "update", "user", "value", "variable", "visualize", "work", "write", "year"], "potential_description_queries_len": 175, "potential_script_queries": ["datetime", "seaborn", "timedelta"], "potential_script_queries_len": 3, "potential_entities_queries": ["basic", "dictionary", "engineering", "new", "run", "timedelta"], "potential_entities_queries_len": 6, "potential_extra_queries": [], "potential_extra_queries_len": 0, "all_components_potential_queries_len": 176}