{"name": "face and facial keypoint detection ", "full_name": " h2 Face and Facial Keypoint detection h4 Select an image h2 Detect all faces in an image h2 Loading in a trained model h2 Keypoint detection h3 TODO Transform each detected face into an input Tensor h3 TODO Detect and display the predicted keypoints ", "stargazers_count": 0, "forks_count": 0, "description": "1 d7 d8b tutorial_py_face_detection. You may find it useful to consult to transformation code in data_load. load_state_dict torch. You should end up with an image like the following with facial keypoints that closely match the facial features on each individual face load in color image for face detection switch red and blue color channels by default OpenCV assumes BLUE comes first not RED as in many images plot the image load in a haar cascade classifier for detecting frontal faces run the detector the output here is an array of detections the corners of each detection box if necessary modify these parameters until you successfully identify every face in a given image make a copy of the original image to plot detections on loop over the detected faces mark the image where each face is found draw a rectangle around each detected face you may also need to change the width of the rectangle drawn depending on image resolution net. An example of face detection on a variety of images is shown below. This step will be similar to the data_transform you created and applied in Notebook 2 whose job was tp rescale normalize and turn any iimage into a Tensor to be accepted as input to your CNN. The ouput should be the predicted the facial keypoints. html as an optional exercise in using Haar detectors. Rescale the detected face to be the expected square size for your CNN 224x224 suggested 4. TODO Transform each detected face into an input TensorYou ll need to perform the following steps for each detected face 1. Face and Facial Keypoint detectionAfter you ve trained a neural network to detect facial keypoints you can then apply this network to any image that includes faces. Hint The sizes of faces detected by a Haar detector and the faces your network has been trained on are of different sizes. numpy reshape to batch_size x 68 x 2 pts load color image for face detection conert RED as in many images load in a haar cascade classifier for detecting frontal faces run detector loop over the detected faces draw a rectangle around each detected face loop over the detected faces from your haar cascade Select the region of interest that is the face in the image. You can even add eye detections https docs. Detect all faces in an imageNext you ll use one of OpenCV s pre trained Haar Cascade classifiers all of which can be found in the detector_architectures directory to find any faces in your selected image. Detect all the faces in an image using a face detector we ll be using a Haar Cascade detector in this notebook. These keypoints will need to be un normalized for display and you may find it helpful to write a helper function like show_keypoints. In the next python cell we load in required libraries for this section of the project. First load your best model by its filename. Reshape the numpy image into a torch image. Pre process those face images so that they are grayscale and transformed to a Tensor of the input size that your net expects. Select an image Select an image to perform facial keypoint detection on you can select any image of faces in the images directory. The neural network expects a Tensor of a certain size as input and so to detect any face you ll first have to do some pre processing. TODO Detect and display the predicted keypointsAfter each face has been appropriately converted into an input Tensor for your network to see as input you can apply your net to each face. Keypoint detectionNow we ll loop over each detected face in an image again only this time you ll transform those faces in Tensors that your CNN can accept as input images. In the code below we loop over each face in the original image and draw a red square on each face in a copy of the original image so as not to modify the original. eval loop over detected faces with haar cascade now we select region of interest which is face in image roi norm_gray. Convert the face from RGB to grayscale2. If you find that your model is generating keypoints that are too small for a given face try adding some padding to the detected roi before giving it as input to your model. Normalize the grayscale image so that its color range falls in 0 1 instead of 0 255 3. Loading in a trained modelOnce you have an image to work with and again you can select any image of faces in the images directory the next step is to pre process that image and feed it into your CNN facial keypoint detector. Use your trained model to detect facial keypoints on the image. load saved_models keypoints_model_1. py to help you perform these processing steps. ", "id": "nancyalaswad90/face-and-facial-keypoint-detection", "size": "3614", "language": "python", "html_url": "https://www.kaggle.com/code/nancyalaswad90/face-and-facial-keypoint-detection", "git_url": "https://www.kaggle.com/code/nancyalaswad90/face-and-facial-keypoint-detection", "script": "data_load utils Normalize transforms ToTensor numpy matplotlib.pyplot models Net Rescale torchvision matplotlib.image ", "entities": "(('you', 'face'), 'convert') (('Select', 'images directory'), 'select') (('we', 'notebook'), 'detect') (('which', 'image'), 'select') (('Rescale', '224x224 4'), 'suggest') (('we', 'original'), 'loop') (('Haar Cascade trained all', 'selected image'), 'use') (('you', 'processing steps'), 'py') (('CNN', 'input images'), 'transform') (('that', 'image'), 'conert') (('it', 'show_keypoints'), 'need') (('sizes', 'are different sizes'), 'Hint') (('that', 'model'), 'try') (('we', 'project'), 'load') (('2 job', 'CNN'), 'be') (('you', 'pre first processing'), 'expect') (('you', 'image resolution net'), 'end') (('it', 'data_load'), 'find') (('next step', 'keypoint CNN facial detector'), 'have') (('TensorYou', 'detected face'), 'transform') (('You', 'eye detections https even docs'), 'add') (('color range', '255 1 instead 0 3'), 'normalize') (('that', 'faces'), 'face') (('net', 'that'), 'process') (('example', 'images'), 'show') ", "extra": "", "label": "No_extra_files", "potential_description_queries": ["apply", "array", "batch_size", "best", "box", "cell", "classifier", "code", "color", "copy", "default", "detect", "detected", "detection", "detector", "directory", "display", "draw", "end", "eval", "even", "every", "exercise", "expected", "eye detections https even docs", "eye", "face", "feed", "find", "following", "found", "function", "grayscale", "help", "helper", "image", "individual", "input", "interest", "job", "load", "loop", "match", "model", "need", "network", "neural", "next", "normalize", "normalized", "not", "numpy", "output", "padding", "perform", "plot", "pre", "processing", "py", "python", "range", "region", "rescale", "reshape", "resolution", "roi", "run", "section", "select", "selected", "similar", "size", "square", "step", "those", "time", "torch", "transform", "transformation", "try", "turn", "until", "up", "width", "work", "write"], "potential_description_queries_len": 86, "potential_script_queries": ["data_load", "numpy", "torchvision"], "potential_script_queries_len": 3, "potential_entities_queries": ["resolution"], "potential_entities_queries_len": 1, "potential_extra_queries": [], "potential_extra_queries_len": 0, "all_components_potential_queries_len": 88}