{"name": "separating nuclei masks using convexity defects ", "full_name": " h1 Statement of the problem h2 1 Show some examples h2 2 Describe the separation idea h3 2 1 Convex enough h3 2 2 Correcting con conex masks h2 3 Modify public kernel Pure image processing LB 0 274 ", "stargazers_count": 0, "forks_count": 0, "description": "Describe the convexity based separation code3. Plot second image 7f34dfccd1bc2e2466ee3d6f74ff05821a0e5404e9cf2c9568da26b59f7afda5 and the np. inf for j in range len points. We can use the approximate distance to the farthest point as indication of badness. Statement of the problemIn this notebook I briefly describe a naive method that attempts to separate merged overlapping nuclei masks using OpenCV convexity analysis. Apply the correction to one of the benchmar submissions It actually improved LB 0. 0 We need then normalized distance to be greater than 12. If it is bigger than a predefined threshold then the shape of the mask is non convex. dist p1 0 p2 0 p1 0 p2 0 p1 1 p2 1 p1 1 p2 1 if dist min_dist. The defect points are returned as as list of start point end point farthest point approximate distance to farthest point. green channel happends to produce slightly better results than the grayscale image and other channels morphological opening size tuned on training data Otsu thresholding Invert the image in case the objects of interest are in the dark side second morphological opening on binary image this time connected components id 0 is for background. The basic idea is described in the steps below 1. Breaks the masks by filtering value mask_i mask i. 1 Convex enoughWe use skimage. 2 We need the point to be at least 80 far compared to the farthest point. Process each test image and create initial masks. line thresh p1 nearest 0 0 0 2 Let us see the separation in action. Essentially we gather all defect points and filter them using this approximate distance. 0 beta doc py_tutorials py_imgproc py_contours py_contours_more_functions py_contours_more_functions. Calculate the regionprops properties props regionprops mask_i cache False 4. In the code below we filter the defect points according to http 1. Appends the splitted mask into a listFinally all masks are grouped together once more into as single one np. That means that background is set to 0 and mask pixels have values from 1 2. Given a segmentation mask2. regionprops method to characterize each individual mask. There is no free lunch after all. Identify convexity defects points b. Describe the separation ideaThe idea is to operate on a blob by blob fashion and detect the points that deviate from the convex hull that is around the blob. connectedComponents to split it into disjoint masks3. Show some examples of overlapping nuclei2. For each one disjoint mask If the disjoint mask is not convex enough a. 1 proceeds on splitting the mask5. More specifically we check the ratio of prop. Show some examplesLet us read some train images and their corresponding masks. The separating method can be applied to a segmentation output after applying skimage label or methods of sort to separated connected clusters. Draw a line of background 0 color to connect every two nearest defect points 2. Connect point p1 to its nearest one. Takes as input as mask created by cv2. 2 Correcting con conex masksThe idea is based on the example here http https docs. com ahassaine pure image processing lb 0 274 Most of the following code is borrowed from the Ali Hassa\u00efne s public kernel. amax masks axis 0 and we call label to separate them once more. We can move to correction 2. Except this function which does apply the separation and filtering 1. I guess by now you have noticed cases like mask 1 mask 5 mask 12 and mask 13 that deviate from nice convex shapes. amax of all corresponding masks. The analysis bellow makes the assumption that nuclei are convex shaped This is not 100 correct. More details here http https docs. After gathering all convexity defect points we begin connecting them by simply connecting the two nearest each time. Modify public kernel Pure image processing LB 0. 1 print no convex Let us apply the above filter to the 42 masks of the example above I guess by now we have a pretty good indication of convexity. This is naively implemented using two nested loops for i in range len points f1 points i p1 tuple contour f1 0 nearest None min_dist np. However I am working on some extentions Connecting only nearest convexity defect points is obviously a poor way For masks near the margins we may not find symmetric convexity defect point id 0 is for background In this loop we gather all defect points so that they can be filtered later on. Our aim is to locate convexity defect points and connect them with a straight line background color hence separating them. AcUse the skimage label to separate the masks into connected blobs. measure import regionprops props regionprops mask_i cache False prop props 0 if prop. Use the splitting methology to each case Let us see what happened to three cases By visually inspecting we can see some good cases and some over splitted cases. ", "id": "voglinio/separating-nuclei-masks-using-convexity-defects", "size": "5152", "language": "python", "html_url": "https://www.kaggle.com/code/voglinio/separating-nuclei-masks-using-convexity-defects", "git_url": "https://www.kaggle.com/code/voglinio/separating-nuclei-masks-using-convexity-defects", "script": "rle_encoding split_and_relabel matplotlib regionprops pyplot pyplot as plt label IPython.display Image skimage.measure process skimage.morphology split_mask_v1 numpy ", "entities": "(('con conex masksThe 2 Correcting idea', 'https here docs'), 'base') (('basic idea', '1'), 'describe') (('0 we', 'them'), 'axis') (('It', 'benchmar submissions'), 'apply') (('0 2 us', 'action'), 'let') (('skimage', 'connected blobs'), 'label') (('Essentially we', 'approximate distance'), 'gather') (('We', 'at least 80 far farthest point'), '2') (('masks', 'together once more single one np'), 'group') (('disjoint mask', 'enough a.'), 'for') (('we', 'convexity'), 'print') (('we', 'simply two nearest'), 'begin') (('that', 'blob'), 'describe') (('12 13 that', 'convex nice shapes'), 'guess') (('defect points', 'start point end point farthest point approximate distance'), 'return') (('We', '12'), 'need') (('mask_i cache False prop', '0'), 'regionprop') (('mask pixels', '1 2'), 'mean') (('nuclei', 'This'), 'make') (('we', 'http'), 'filter') (('they', 'defect points'), 'be') (('separating method', 'connected clusters'), 'apply') (('aim', 'hence them'), 'be') (('visually we', 'splitted cases'), 'let') (('props', 'mask_i cache'), 'calculate') (('image processing com ahassaine pure 0 274 Most', 'Ali public kernel'), 'lb') (('i', 'background'), 'be') (('f1 points i', 'range len points'), 'implement') (('that', 'OpenCV convexity analysis'), 'statement') (('We', 'badness'), 'use') (('which', '1'), 'except') (('then shape', 'mask'), 'be') (('More specifically we', 'prop'), 'check') (('us', 'train images'), 'show') "}